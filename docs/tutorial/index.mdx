---
sidebar_position: 0
slug: /tutorial
---

# Tutorial

:::caution
TODO: Video
:::

## Test invoking the Command

We now have a Command we can invoke. It doesn't do anything yet (we'll get to that in a sec), but we can invoke it using the `eventual invoke` CLI.

As a test, let's invoke the command we just created:

```
npx eventual invoke submitTask "this is my task description"
```

It will echo back the output:

```
> this is my task description
```

:::tip
The `submitTask` is a reference to the name we gave our command with `command("submitTask", .. )`.
:::

## Create an approval workflow

Let's now create a workflow for orchestrating the approval process. We'll then update our `submitTask` command to invoke it.

First, create a new file, `approval-process.ts` and create a workflow.

```ts
import { workflow } from "@eventual/core";

export const approvalProcess = workflow(
  "approvalProcess",
  async (description: string) => {
    // TODO
  }
);
```

:::caution Remember to re-export
Remember to go back to your `index.ts` and re-export the workflow

```ts
export * from "./approval-process.js";
```

:::

:::tip
It is not necessary to create a file for each command, workflow, etc. It's just usually a good practice to organize your business logic into individual files with easy-to-understand names.
:::

## Create an Activity to wait for approval

Before we can finish our workflow, we need to create an activity for the workflow to call. This activity will store a token in a database that we will look up later.

By now, you've probably picked up on the pattern - first, create a new file for the activity, `wait-for-approval.ts` and add the following code:

```ts
import { activity } from "@eventual/core";

export const waitForApproval = activity(
  "waitForApproval",
  async (input: { taskId: string; description: string }) => {
    return asyncResult<boolean>(async (token) => {
      // write the token into a database
    });
  }
);
```

## Add a DynamoDB Table to store our Tasks and their Tokens

Eventual does not currently provide a database out of the box. Instead, Eventual can be easily integrated with other services using the CDK.

To store our tasks, we'll create a DynamoDB Table and give our Service access to it. Head on over to `infra/src/app.ts`.

You'll see some code like this:

```ts
import { App, Stack, CfnOutput } from "aws-cdk-lib";
import { Service } from "@eventual/aws-cdk";

const app = new App();
const stack = new Stack(app, "tutorial");

import type * as tutorial from "@tutorial/service";

const service = new Service<typeof tutorial>(stack, "Service", {
  name: "tutorial",
  entry: require.resolve("@tutorial/service"),
});
```

This is where we can create and configure AWS Resources using the AWS CDK.

First, import and create a DynamoDB Table using the CDK.

```ts
import { Table, AttributeType, BillingMode } from "aws-cdk-lib/aws-dynamodb";

const table = new Table(stack, "Table", {
  partitionKey: {
    name: "taskId",
    type: AttributeType.STRING,
  },
  billingMode: BillingMode.PAY_PER_REQUEST,
});
```

Next, inject the table's ARN as an environment variable into the Service:

```ts
service.addEnvironment("TABLE_ARN", table.tableArn);
```

Then, grant the service read and write access permissions:

```ts
table.grantReadWriteData(service);
```

Finally, deploy the service:

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";

<Tabs groupId="npm">
  <TabItem value="npm" label="npm" default>
    <CodeBlock>npm run deploy</CodeBlock>
  </TabItem>
  <TabItem value="yarn" label="yarn">
    <CodeBlock>yarn deploy</CodeBlock>
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    <CodeBlock>pnpm run deploy</CodeBlock>
  </TabItem>
</Tabs>

âœ… Done - we have created a DynamoDB Table and have access to it in our Service code.

## Install DynamoDB dependencies

Add `@aws-sdk/client-dynamodb` and `@aws-sdk/lib-dynamodb` to your `packages/service/package.json`.

```json
{
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3",
    "@aws-sdk/lib-dynamodb": "^3"
  }
}
```

And then install the dependencies:

<Tabs groupId="npm">
  <TabItem value="npm" label="npm" default>
    <CodeBlock>npm i</CodeBlock>
  </TabItem>
  <TabItem value="yarn" label="yarn">
    <CodeBlock>yarn</CodeBlock>
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    <CodeBlock>pnpm i</CodeBlock>
  </TabItem>
</Tabs>

## Store the Task and its Token in DynamoDB

Head on back to to the `wait-for-approval.ts` activity and create a DynamoDB client.

```ts
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DocumentClient, PutComand } from "@aws-sdk/lib-dynamodb";

const dynamoClient = new DynamoDBClient({});
const docClient = DocumentClient.from(dynamoClient);
```

Grab the DynamoDB Table (that we just created) from the environment variables:

```ts
const tableArn = process.env.TABLE_ARN!;
```

Finally, update the activity to store the task and its token in DynamoDB.

```ts
import { activity } from "@eventual/core";

export const waitForApproval = activity(
  "waitForApproval",
  async (input: { taskId: string; description: string }) => {
    return asyncResult<boolean>(async (token) => {
      await docClient.send(
        new PutCommand({
          TableName: tableArn,
          Item: {
            taskId: input.taskId,
            token,
            description: input.description,
          },
        })
      );
    });
  }
);
```

:::tip
In this example, we're working with the low-level DynamoDB API. We recommend using [ElectroDB](https://github.com/tywalch/electrodb) instead which greatly simplifies the job of storing and querying records in DynamoDB.
:::

## Add a new command to approve/deny the Task

Let's add another command, `completeTask`, to approve or deny the task.

```ts
import { waitForApproval } from "./wait-for-approval.js";

export const completeTask = command(
  "completeTask",
  async (input: { taskId: string; approved: boolean }) => {
    // todo
  }
);
```

This command will take a reference to the `taskId` to complete and a boolean `approved` indicating "approved" when `true` or "denied" when `false`.

First, look up the Task in DynamoDB:

```ts
const response = await docClient.send(
  new GetCommand({
    TableName: tableArn,
    Key: {
      taskId: input.taskId,
    },
  })
);
```

Then, throw a `404` error if the task doesn't exist.

```ts
if (response.Item === undefined) {
  throw new HttpError({
    code: 404,
    message: `task with ${input.taskId} is not found`,
  });
}
```

:::info
See the [HttpError](/reference/api/command#httperror) documentation.
:::

Finally, call `sendActivitySuccess` on the `waitForApproval` activity to complete the async activity.

```ts
// send the result for the activity
await waitForApproval.sendActivitySuccess({
  activityToken: response.Item.token,
  result: input.approved,
});
```

:::info
See the [Async Activity](/reference/orchestration/activity#async-activity) documentation.
:::

## Scratch

continuing from quick-start
delete that shit
add a command for submit task
add a workflow that waits for a human to approve
add a command to approve
add an activity to console.log("email sent")
deploy
LOCAL???

run the submit-task command
go to the executor logs -> see that it hasn't logged
then run the approve-command
go to the executor logs -> see that it HAS logged
write a test

1. ship local and determine 0-1 experience
2. reduce resource count
3. optimize local
4. fix weird bug (FFUUUUCKKKKK)
